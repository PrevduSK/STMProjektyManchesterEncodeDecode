@startuml
title menchester read with intreup and timer couter processing
' comment
start
' For write via VScode must by filename.puml
' This set can read 0s signal or 1s signal, but it not read data
' This set read values after Falling or Rising, but not between 

partition "int **main**(void)" {
:HAL_NVIC_EnableIRQ(EXTI0_IRQn); \nHAL_InitTick(SystemCoreClock);;
}

fork
partition "**While** in function: int **main**(void) " {
while (  **While** endless loop ) is (yes)

if ( ( !edge_rise_fall_Flag  && !tim_count_reset_Flag ) && count_edge >= 2 ) then (yes)
floating note left: &&  AND
    :actual_tick = HAL_GetTick();;
    
	if ( tick_last_timer != 0 ) then (yes)
		:timer_interval = actual_tick - tick_last_timer;;

		if (  ( timer_interval > tick_count_prim ) && ( timer_interval <=  (uint32_t) tick_count_prim*1.5f  )   ) then (yes)
			:tick_current_timer = HAL_GetTick(); \ntim_count_reset_Flag = true;;
		endif
	endif
endif


	'  ---------------------------- edge_Flag rection ------------------------- 
if ( edge_rise_fall_Flag || tim_count_reset_Flag )  then (yes) 
floating note left: ||  OR		
	:time_delay = (tick_count_prim != 0) ?  tick_count_prim_half : Time_delay_Count_not_set; \nlast_time_tick = edge_rise_fall_Flag ? tick_count_last_edge :  tick_last_timer;;


   		floating note left:   Time_delay_Count_not_set == 120U ~ 120ms
	if ( (HAL_GetTick() - last_time_tick) > time_delay ) then (yes)
		
        if ( edge_rise_fall_Flag ) then (yes)
            :interval_btw_tick = tick_cunt_current_edge - tick_count_last_edge; \ntick_count_last_edge = tick_cunt_current_edge; \ntick_last_timer = tick_count_current_edge;;
        else (no) 
            :tick_last_timer = tick_current_timer;;
        endif
        :bit_read_enab = true; \nedge_rise_fall_Flag = false; \ntim_count_reset_Flag = false;;
	endif
	  

	if ( count_edge == 2 ) then (yes)
		:tick_count_prim = interval_btw_tick; \ntick_count_prim_half =   (uint32_t) (tick_count_prim/2 );;
	endif
	
	if ( bit_read_enab ) then (yes)
				
	  	:bit_read_enab = false;;	
		if ( HAL_GPIO_ReadPin(Manchaster_In_GPIO_Port, Manchaster_In_Pin) == GPIO_PIN_RESET) then (yes)
		note right: GPIO_PIN_RESET == 0
					'  :manchester_mass |= 0; \nmanchester_mass <<= 1; \ncount_bit++;;
		:last_state_pin = HAL_GPIO_ReadPin(Manchaster_In_GPIO_Port, Manchaster_In_Pin); \nHAL_UART_Transmit(&huart1, (uint8_t *) "0", sizeof("0"), 1);;
				 		
			
		      		' if(HAL_GPIO_ReadPin(Manchaster_In_GPIO_Port, Manchaster_In_Pin) == GPIO_PIN_SET) then (yes)
		else (no)
			
					' \nmanchester_mass <<= 1; \ncount_bit++; 
			:manchester_mass |= 1; \nlast_state_pin = HAL_GPIO_ReadPin(Manchaster_In_GPIO_Port, Manchaster_In_Pin); \nHAL_UART_Transmit(&huart1, (uint8_t *) "1", sizeof("1"), 1);;
		   
		endif
			
		:count_bit++;;
		if(count_bit >= 16) then (16,17,.. >= 16)
					' :HAL_TIM_OC_Stop_IT(&htim1, TIM_CHANNEL_1);
			:HAL_NVIC_DisableIRQ(EXTI0_IRQn); \nrecived_mass[massg_count] = manchester_mass;;
			if (massg_count < MAX_mass_recived) then (yes)
				note right: MAX_mass_recived == 1
				:massg_count++;;
			endif
					' // HAL_UART_Transmit(&huart1, (uint8_t *) "\r\n", sizeof("\r\n"), 1);
			:count_bit = 0;;
					' //manchester_mass = 0;
		else ( 0,1, ..,15)
			:manchester_mass <<= 1;;
		endif
	endif

	  endif
	if ( massg_count == MAX_mass_recived ) then (yes)
		  ' //HAL_SuspendTick();
		:break;;
		:**While** end;
		break	
		' detach
		' stop
	endif


  

endwhile
-[hidden]->
  detach
}


' -------------------------------- hedlers for interupt -----------------------------
' ---------------------- Callback for TIM_OC---------------------------
'fork again
 '  partition "void **HAL_TIM_OC_DelayElapsedCallback**(TIM_HandleTypeDef * htim)"{
	' start
'	if (htim->Instance == TIM2) then (yes)
 '   		:__HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_CC1); \ntim_count_reset_Flag = true;;
'	endif
'	end
 '  }

' --------------------------------Callback for GPIO_EXTI------------------------------
fork again
   partition "void **HAL_GPIO_EXTI_Rising_Callback**(uint16_t GPIO_Pin)"{
	if (GPIO_Pin == Manchaster_In_Pin) then (yes)
		:__HAL_GPIO_EXTI_CLEAR_FLAG(Manchaster_In_Pin); \ntick_cunt_current_edge = HAL_GetTick(); \nedge_rise_fall_Flag = true; \ncount_edge++;
	endif
	end
   }


fork again
   partition "void **HAL_GPIO_EXTI_Falling_Callback**(uint16_t GPIO_Pin)"{
	if (GPIO_Pin == Manchaster_In_Pin) then (yes)
		:__HAL_GPIO_EXTI_CLEAR_FLAG(Manchaster_In_Pin); \ntick_cunt_current_edge = HAL_GetTick(); \nedge_rise_fall_Flag = true; \ncount_edge++;
	endif
	end
   }
end fork
' end merge


partition "int **main**(void)" {
:code;
}
stop

@enduml
